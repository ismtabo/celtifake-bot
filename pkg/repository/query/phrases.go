// Code generated by github.com/andreyvit/sqlstruct. DO NOT EDIT. (@generated)
package query

import (
	"context"
	"database/sql"
	"errors"
	"github.com/andreyvit/sqlexpr"
	"github.com/ismtabo/phrases-of-the-year/pkg/repository/dbo"
	"time"
)

type QueryResultLogger interface {
	IsLoggingQueryResults() bool
	LogQueryResult(ctx context.Context, method string, query string, args []interface{}, start time.Time, rowCount int, err error, result interface{})
}

var ErrNoneAffected = errors.New("no rows affected")

func VerifyAffected(res sql.Result, err error) error {
	if err != nil {
		return err
	}
	affected, err := res.RowsAffected()
	if err != nil {
		return err
	}
	if affected == 0 {
		return ErrNoneAffected
	}
	return nil
}

type Facet int

const (
	NoneFacet Facet = iota
	AllFacet
	AllallFacet
	ImmutableFacet
	InsertFacet
	MutableFacet
	PKFacet
)

func (f Facet) String() string {
	switch f {
	case NoneFacet:
		return "none"
	case AllFacet:
		return "all"
	case AllallFacet:
		return "allall"
	case ImmutableFacet:
		return "immutable"
	case InsertFacet:
		return "insert"
	case MutableFacet:
		return "mutable"
	case PKFacet:
		return "pk"
	default:
		panic("unknown facet")
	}
}

const PhrasesTable sqlexpr.Table = "phrases"

const (
	PhraseId        sqlexpr.Column = "id"
	PhraseContent   sqlexpr.Column = "content"
	PhraseGroup     sqlexpr.Column = "group_"
	PhraseAuthor    sqlexpr.Column = "author"
	PhraseCreatedAt sqlexpr.Column = "created_at"
)

func ScanPhrase(row *sql.Row, fct Facet) (*dbo.Phrase, error) {
	v := new(dbo.Phrase)
	err := ScanPhraseInto(row, v, fct)
	if err != nil {
		return nil, err
	}
	return v, nil
}

func ScanNextPhrase(rows *sql.Rows, fct Facet) (*dbo.Phrase, error) {
	v := new(dbo.Phrase)
	err := ScanNextPhraseInto(rows, v, fct)
	if err != nil {
		return nil, err
	}
	return v, nil
}

func ScanPhraseInto(row *sql.Row, v *dbo.Phrase, fct Facet) error {
	switch fct {
	case NoneFacet:
		panic("cannot scan noneFacet!")
	case PKFacet:
		return row.Scan(&v.Id)
	case InsertFacet:
		return row.Scan(&v.Id, &v.Content, &v.Group, &v.Author, &v.CreatedAt)
	case AllallFacet:
		return row.Scan(&v.Id, &v.Content, &v.Group, &v.Author, &v.CreatedAt)
	case AllFacet:
		return row.Scan(&v.Id, &v.Content, &v.Group, &v.Author, &v.CreatedAt)
	case ImmutableFacet:
		return row.Scan(&v.Id)
	case MutableFacet:
		return row.Scan(&v.Content, &v.Group, &v.Author, &v.CreatedAt)
	default:
		panic("github.com/ismtabo/phrases-of-the-year/pkg/repository/dbo.Phrase does not support facet " + fct.String())
	}
}

func ScanNextPhraseInto(rows *sql.Rows, v *dbo.Phrase, fct Facet) error {
	switch fct {
	case NoneFacet:
		panic("cannot scan noneFacet!")
	case PKFacet:
		return rows.Scan(&v.Id)
	case InsertFacet:
		return rows.Scan(&v.Id, &v.Content, &v.Group, &v.Author, &v.CreatedAt)
	case AllallFacet:
		return rows.Scan(&v.Id, &v.Content, &v.Group, &v.Author, &v.CreatedAt)
	case AllFacet:
		return rows.Scan(&v.Id, &v.Content, &v.Group, &v.Author, &v.CreatedAt)
	case ImmutableFacet:
		return rows.Scan(&v.Id)
	case MutableFacet:
		return rows.Scan(&v.Content, &v.Group, &v.Author, &v.CreatedAt)
	default:
		panic("github.com/ismtabo/phrases-of-the-year/pkg/repository/dbo.Phrase does not support facet " + fct.String())
	}
}

func ScanAllPhrases(rows *sql.Rows, fct Facet) ([]*dbo.Phrase, error) {
	defer rows.Close()
	var result []*dbo.Phrase
	for rows.Next() {
		v, err := ScanNextPhrase(rows, fct)
		if err != nil {
			return result, err
		}
		result = append(result, v)
	}
	return result, rows.Err()
}

func AddPhraseFields(s sqlexpr.Fieldable, fct Facet) {
	switch fct {
	case NoneFacet:
		return
	case PKFacet:
		s.AddField(sqlexpr.Column("id"))
	case InsertFacet:
		s.AddField(sqlexpr.Column("id"))
		s.AddField(sqlexpr.Column("content"))
		s.AddField(sqlexpr.Column("group_"))
		s.AddField(sqlexpr.Column("author"))
		s.AddField(sqlexpr.Column("created_at"))
	case AllallFacet:
		s.AddField(sqlexpr.Column("id"))
		s.AddField(sqlexpr.Column("content"))
		s.AddField(sqlexpr.Column("group_"))
		s.AddField(sqlexpr.Column("author"))
		s.AddField(sqlexpr.Column("created_at"))
	case AllFacet:
		s.AddField(sqlexpr.Column("id"))
		s.AddField(sqlexpr.Column("content"))
		s.AddField(sqlexpr.Column("group_"))
		s.AddField(sqlexpr.Column("author"))
		s.AddField(sqlexpr.Column("created_at"))
	case ImmutableFacet:
		s.AddField(sqlexpr.Column("id"))
	case MutableFacet:
		s.AddField(sqlexpr.Column("content"))
		s.AddField(sqlexpr.Column("group_"))
		s.AddField(sqlexpr.Column("author"))
		s.AddField(sqlexpr.Column("created_at"))
	default:
		panic("github.com/ismtabo/phrases-of-the-year/pkg/repository/dbo.Phrase does not support facet " + fct.String())
	}
}

func AddPhraseSetters(s sqlexpr.Settable, v *dbo.Phrase, fct Facet) {
	switch fct {
	case NoneFacet:
		return
	case PKFacet:
		s.Set(sqlexpr.Column("id"), v.Id)
	case InsertFacet:
		s.Set(sqlexpr.Column("id"), v.Id)
		s.Set(sqlexpr.Column("content"), v.Content)
		s.Set(sqlexpr.Column("group_"), v.Group)
		s.Set(sqlexpr.Column("author"), v.Author)
		s.Set(sqlexpr.Column("created_at"), v.CreatedAt)
	case AllallFacet:
		s.Set(sqlexpr.Column("id"), v.Id)
		s.Set(sqlexpr.Column("content"), v.Content)
		s.Set(sqlexpr.Column("group_"), v.Group)
		s.Set(sqlexpr.Column("author"), v.Author)
		s.Set(sqlexpr.Column("created_at"), v.CreatedAt)
	case AllFacet:
		s.Set(sqlexpr.Column("id"), v.Id)
		s.Set(sqlexpr.Column("content"), v.Content)
		s.Set(sqlexpr.Column("group_"), v.Group)
		s.Set(sqlexpr.Column("author"), v.Author)
		s.Set(sqlexpr.Column("created_at"), v.CreatedAt)
	case ImmutableFacet:
		s.Set(sqlexpr.Column("id"), v.Id)
	case MutableFacet:
		s.Set(sqlexpr.Column("content"), v.Content)
		s.Set(sqlexpr.Column("group_"), v.Group)
		s.Set(sqlexpr.Column("author"), v.Author)
		s.Set(sqlexpr.Column("created_at"), v.CreatedAt)
	default:
		panic("github.com/ismtabo/phrases-of-the-year/pkg/repository/dbo.Phrase does not support facet " + fct.String())
	}
}

func AddPhraseConditions(s sqlexpr.Whereable, v *dbo.Phrase, fct Facet) {
	switch fct {
	case NoneFacet:
		return
	case PKFacet:
		s.AddWhere(sqlexpr.Eq(sqlexpr.Column("id"), v.Id))
	case InsertFacet:
		s.AddWhere(sqlexpr.Eq(sqlexpr.Column("id"), v.Id))
		s.AddWhere(sqlexpr.Eq(sqlexpr.Column("content"), v.Content))
		s.AddWhere(sqlexpr.Eq(sqlexpr.Column("group_"), v.Group))
		s.AddWhere(sqlexpr.Eq(sqlexpr.Column("author"), v.Author))
		s.AddWhere(sqlexpr.Eq(sqlexpr.Column("created_at"), v.CreatedAt))
	case AllallFacet:
		s.AddWhere(sqlexpr.Eq(sqlexpr.Column("id"), v.Id))
		s.AddWhere(sqlexpr.Eq(sqlexpr.Column("content"), v.Content))
		s.AddWhere(sqlexpr.Eq(sqlexpr.Column("group_"), v.Group))
		s.AddWhere(sqlexpr.Eq(sqlexpr.Column("author"), v.Author))
		s.AddWhere(sqlexpr.Eq(sqlexpr.Column("created_at"), v.CreatedAt))
	case AllFacet:
		s.AddWhere(sqlexpr.Eq(sqlexpr.Column("id"), v.Id))
		s.AddWhere(sqlexpr.Eq(sqlexpr.Column("content"), v.Content))
		s.AddWhere(sqlexpr.Eq(sqlexpr.Column("group_"), v.Group))
		s.AddWhere(sqlexpr.Eq(sqlexpr.Column("author"), v.Author))
		s.AddWhere(sqlexpr.Eq(sqlexpr.Column("created_at"), v.CreatedAt))
	case ImmutableFacet:
		s.AddWhere(sqlexpr.Eq(sqlexpr.Column("id"), v.Id))
	case MutableFacet:
		s.AddWhere(sqlexpr.Eq(sqlexpr.Column("content"), v.Content))
		s.AddWhere(sqlexpr.Eq(sqlexpr.Column("group_"), v.Group))
		s.AddWhere(sqlexpr.Eq(sqlexpr.Column("author"), v.Author))
		s.AddWhere(sqlexpr.Eq(sqlexpr.Column("created_at"), v.CreatedAt))
	default:
		panic("github.com/ismtabo/phrases-of-the-year/pkg/repository/dbo.Phrase does not support facet " + fct.String())
	}
}

func BuildSelectFromPhrases(fct Facet) *sqlexpr.Select {
	s := &sqlexpr.Select{From: sqlexpr.Table("phrases")}
	AddPhraseFields(s, fct)
	return s
}

func BuildInsertPhrase(v *dbo.Phrase, setFct, retFct Facet) *sqlexpr.Insert {
	s := &sqlexpr.Insert{Table: sqlexpr.Table("phrases")}
	AddPhraseSetters(s, v, setFct)
	AddPhraseFields(s, retFct)
	return s
}

func BuildUpdatePhrase(v *dbo.Phrase, condFct, updateFct, retFct Facet) *sqlexpr.Update {
	s := &sqlexpr.Update{Table: sqlexpr.Table("phrases")}
	AddPhraseSetters(s, v, updateFct)
	AddPhraseConditions(s, v, condFct)
	AddPhraseFields(s, retFct)
	return s
}

func BuildDeletePhrase(v *dbo.Phrase, condFct Facet) *sqlexpr.Delete {
	s := &sqlexpr.Delete{Table: sqlexpr.Table("phrases")}
	AddPhraseConditions(s, v, condFct)
	return s
}

func FetchPhrase(ctx context.Context, ex sqlexpr.Executor, fct Facet, where sqlexpr.Expr, f func(*sqlexpr.Select)) (*dbo.Phrase, error) {
	start := time.Now()
	s := BuildSelectFromPhrases(fct)
	if where != nil {
		s.AddWhere(where)
	}
	if f != nil {
		f(s)
	}
	query, args := sqlexpr.Build(s)
	row := ex.QueryRowContext(ctx, query, args...)
	result, err := ScanPhrase(row, fct)
	if logger, ok := ex.(QueryResultLogger); ok && logger.IsLoggingQueryResults() {
		logger.LogQueryResult(ctx, "FetchPhrase", query, args, start, map[bool]int{false: 0, true: 1}[err == nil], err, result)
	}
	return result, err
}

func FetchPhrases(ctx context.Context, ex sqlexpr.Executor, fct Facet, where sqlexpr.Expr, f func(*sqlexpr.Select)) ([]*dbo.Phrase, error) {
	start := time.Now()
	s := BuildSelectFromPhrases(fct)
	if where != nil {
		s.AddWhere(where)
	}
	if f != nil {
		f(s)
	}
	query, args := sqlexpr.Build(s)
	rows, err := ex.QueryContext(ctx, query, args...)
	if err != nil {
		if logger, ok := ex.(QueryResultLogger); ok && logger.IsLoggingQueryResults() {
			logger.LogQueryResult(ctx, "FetchPhrases", query, args, start, 0, err, nil)
		}
		return nil, err
	}
	result, err := ScanAllPhrases(rows, fct)
	if logger, ok := ex.(QueryResultLogger); ok && logger.IsLoggingQueryResults() {
		logger.LogQueryResult(ctx, "FetchPhrases", query, args, start, len(result), err, result)
	}
	return result, err
}

func InsertPhrase(ctx context.Context, ex sqlexpr.Executor, v *dbo.Phrase, setFct, retFct Facet, f func(*sqlexpr.Insert)) error {
	start := time.Now()
	s := BuildInsertPhrase(v, setFct, retFct)
	if f != nil {
		f(s)
	}
	query, args := sqlexpr.Build(s)
	if retFct == NoneFacet {
		res, err := ex.ExecContext(ctx, query, args...)
		if logger, ok := ex.(QueryResultLogger); ok && logger.IsLoggingQueryResults() {
			logger.LogQueryResult(ctx, "InsertPhrase", query, args, start, -1, err, res)
		}
		return err
	} else {
		row := ex.QueryRowContext(ctx, query, args...)
		err := ScanPhraseInto(row, v, retFct)
		if logger, ok := ex.(QueryResultLogger); ok && logger.IsLoggingQueryResults() {
			logger.LogQueryResult(ctx, "InsertPhrase", query, args, start, 1, err, v)
		}
		return err
	}
}

func UpdatePhrase(ctx context.Context, ex sqlexpr.Executor, v *dbo.Phrase, condFct, updateFct, retFct Facet, f func(*sqlexpr.Update)) error {
	start := time.Now()
	s := BuildUpdatePhrase(v, condFct, updateFct, retFct)
	if f != nil {
		f(s)
	}
	query, args := sqlexpr.Build(s)
	if retFct == NoneFacet {
		res, err := ex.ExecContext(ctx, query, args...)
		if logger, ok := ex.(QueryResultLogger); ok && logger.IsLoggingQueryResults() {
			logger.LogQueryResult(ctx, "UpdatePhrase", query, args, start, -1, err, res)
		}
		return VerifyAffected(res, err)
	} else {
		row := ex.QueryRowContext(ctx, query, args...)
		err := ScanPhraseInto(row, v, retFct)
		if logger, ok := ex.(QueryResultLogger); ok && logger.IsLoggingQueryResults() {
			logger.LogQueryResult(ctx, "UpdatePhrase", query, args, start, 1, err, v)
		}
		return err
	}
}

func DeletePhrase(ctx context.Context, ex sqlexpr.Executor, v *dbo.Phrase, condFct Facet, f func(*sqlexpr.Delete)) error {
	start := time.Now()
	s := BuildDeletePhrase(v, condFct)
	if f != nil {
		f(s)
	}
	query, args := sqlexpr.Build(s)
	res, err := ex.ExecContext(ctx, query, args...)
	if logger, ok := ex.(QueryResultLogger); ok && logger.IsLoggingQueryResults() {
		logger.LogQueryResult(ctx, "DeletePhrase", query, args, start, -1, err, res)
	}
	return VerifyAffected(res, err)
}
